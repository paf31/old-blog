SUNDAY, DECEMBER 5, 2010
Greatest Fixed Points and Anamorphisms in C#
As promised in my last post, I'm now going to go over how to encode greatest fixed point types and their anamorphisms in C# using existentials.

A recap: we use the isomorphisms
exists X. T ~ forall R. (forall X. T -> R) -> R
\pack X x. \R. \f. f[X] (x)
and
Nu F ~ exists X. X * (X -> F X)
\x. pack Nu F x out
where the second morphism has an inverse given by
\pack X x f. ana f (x)
where  ana f denotes the anamorphism generated by f.

As an example, we are going to treat the case of infinite streams over an alphabet A:
Stream A := Nu (\X. A * X)
Let's first interpret the second isomorphism above in this context. We have
Stream A ~ exists X. X * (X -> X * A)
The packed type here acts as an indicator of the position in the stream. We could take X = int. For constant streams, we could even let X = 1, the unit type. Then, we can interpret the existential package pack X a f as the stream with first few elements a, outr f(a), outr f outr f(a), ...

Let's translate this into C#. First, our definition of a stream, using the first isomorphism above to encode existentials as universals:
struct StreamF<A, T>
{
    public T Seed { get; set; }
    public Func<T, Tuple<T, A>> Generator { get; set; }
}

interface StreamFunction<A, R>
{
    R Apply<T>(StreamF<A, T> n);
}

interface Stream<A>
{
    R Apply<R>(StreamFunction<A, R> f);
}
With that definition, we can proceed to define anamorphisms in the way one would expect:
class AnaStream<A, T> : Stream<A>
{
    private readonly StreamF<A, T> sf;

    public AnaStream(StreamF<A, T> sf)
    {
        this.sf = sf;
    }

    public R Apply<R>(StreamFunction<A, R> f)
    {
        return f.Apply<T>(sf);
    }
}

public static Func<T, Stream<A>> Ana<A, T>(Func<T, Tuple<T, A>> generator)
{
    return seed => new AnaStream<A, T>(new StreamF<A, T>
    {
        Seed = seed,
        Generator = generator
    });
}
With anamorphisms under our belt, we can now define constant streams with ease:
public static Stream<T> Const<T>(T t)
{
    return Ana<T, Unit>(u => Tuple.Create<Unit, T>(u, t))(new Unit());
}
with Unit here denoting any one-point type.

Consing an element onto the front of a stream is a little tricky. The idea is to replace the underlying type of the existential package T with the type Maybe T := 1 + T. Here the unit type corresponds to the head of the new stream and the T corresponds to the tail. In order to get at the underlying type of the package, we have to wrap any StreamFunction<A> object which will be responsible for unpacking the existential package:
class ConsFunction<A, R> : StreamFunction<A, R>
{
    private A head;
    private StreamFunction<A, R> tailFunction;

    public ConsFunction(StreamFunction<A, R> tailFunction, A head)
    {
        this.head = head;
        this.tailFunction = tailFunction;
    }

    public R Apply<T>(StreamF<A, T> n)
    {
        return tailFunction.Apply<Either<Unit, T>>(new StreamF<A, Either<Unit, T>>
        {
            Seed = Either<Unit, T>.inl(new Unit()),
            Generator = pair => pair.Case(
                u => Tuple.Create<Either<Unit, T>, A>(
                    Either<Unit, T>.inr(n.Seed), head),
                new Func<T, Tuple<Either<Unit, T>, A>>(t =>
                {
                    Tuple<T, A> next = n.Generator(t);
                    return Tuple.Create<Either<Unit, T>, A>(
                        Either<Unit, T>.inr(next.Item1), next.Item2);
                }))
        });
    }
}

class ConsStream<A> : Stream<A>
{
    private Stream<A> tail;
    private A head;

    public ConsStream(Stream<A> tail, A head)
    {
        this.tail = tail;
        this.head = head;
    }

    public R Apply<R>(StreamFunction<A, R> tailFunction)
    {
        return tail.Apply(new ConsFunction<A, R>(tailFunction, head));
    }
}

public static Stream<A> Cons<A>(this Stream<A> s, A a)
{
    return new ConsStream<A>(s, a);
}
Here, the Either class is used to represent sum types. It has two constructors and a generic method used to destruct its values:
class Either<A, B>
{
    private bool flag;
    private A a;
    private B b;

    private Either() { }

    public static Either<A, B> inl(A value)
    {
        return new Either<A, B>
        {
            flag = true,
            a = value
        };
    }

    public static Either<A, B> inr(B value)
    {
        return new Either<A, B>
        {
            flag = false,
            b = value
        };
    }

    public T Case<T>(Func<A, T> aFunc, Func<B, T> bFunc)
    {
        return flag ? aFunc(a) : bFunc(b);
    }
}
To take an element from the head of a stream, we can use the same generator function, but shift the seed value by one iteration:
class NextStream<A, T> : Stream<A>
{
    private Stream<A> s;
    private StreamF<A, T> n;

    public NextStream(Stream<A> s, StreamF<A, T> n)
    {
        this.s = s;
        this.n = n;
    }

    public R Apply<R>(StreamFunction<A, R> f)
    {
        return f.Apply<T>(new StreamF<A, T>
        {
            Seed = n.Generator(n.Seed).Item1,
            Generator = n.Generator
        });
    }
}

class NextFunction<A> : StreamFunction<A, Tuple<A, Stream<A>>>
{
    private Stream<A> s;

    public NextFunction(Stream<A> s)
    {
        this.s = s;
    }

    public Tuple<A, Stream<A>> Apply<T>(StreamF<A, T> n)
    {
        return Tuple.Create<A, Stream<A>>(n.Generator(n.Seed).Item2,
            new NextStream<A, T>(s, n));
    }
}

public static Tuple<A, Stream<A>> Next<A>(this Stream<A> s)
{
    return s.Apply<Tuple<A, Stream<A>>>(new NextFunction<A>(s));
}
Next time I plan to give a treatment of another greatest fixed point type - the conatural numbers - and their arithmetic.
