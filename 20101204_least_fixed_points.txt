SATURDAY, DECEMBER 4, 2010
Least Fixed Points and Catamorphisms in C#
I've been trying to find a nice way to encode least fixed points in C# for a while. At first, I tried to define a functor interface. Unfortunately, due to C#'s lack of type operator polymorphism, there isn't really a nice way to do this in a type-safe way. However, there is a nice way to encode least fixed points without using the functorial structure at all.


We use the isomorphism


Mu F ~ forall X. (F X -> X) -> X
The isomorphism is given by
x : Mu F -> \X. \f. cata f (x)
where cata f denotes the catamorphism generated by f.


The inverse is given by
y -> y[Mu f] (in)
where in is the algebra morphism F Mu F -> Mu F. Note that cata in = id implies that this is indeed an inverse.


Unfortunately, we can't capture the type constructor F as a first-class value in C#, again due to the lack of type operator polymorphism.


For now, let's take the example of cons lists. We have
List A = Mu (\X. 1 + A.X)
Translating this into C#, we have
struct ListF<A, T>
{
    public A a;
    public T t;
}


interface List<A>
{
    T Cata<T>(Func<ListF<A, T>?, T> generator);
}
How can we use this? Well, we can define the empty list:
class EmptyList<A> : List<A>
{
    public T Cata<T>(Func<ListF<A, T>?, T> generator)
    {
        return generator(null);
    }
}
and a means of consing an element onto the front of an existing list:


class Cons<A> : List<A>
{
    public A x;
    public List<A> xs;


    public Cons(A x, List<A> xs)
    {
        this.x = x;
        this.xs = xs;
    }


    public T Cata<T>(Func<ListF<A, T>?, T> generator)
    {
        return generator(new ListF<A, T>
        {
            a = x,
            t = xs.Cata(generator)
        });           
    }
} 
Finally we can turn a List<A> into an array A[]:
public static T[] ToArray<T>(this List<T> list)
{
    return list.Cata<T[]>(x => x.HasValue
        ? new T[] {x.Value.a}.Concat(x.Value.t).ToArray()
        : new T[0]);
}
Some extension methods can make the creation of lists easier:
public static List<T> Empty<T>()
{
    return new EmptyList<T>();
}


public static List<T> Cons<T>(this List<T> list, T t)
{
    return new Cons<T>(t, list);
}
Now we can manipulate lists in the ways you would expect:
Empty<int>().Cons(1).Cons(2).Cons(3).ToArray()
>> [3, 2, 1]
We can also encode greatest fixed points using
Nu F ~ Exists X. X * (X -> FX)
using the encoding of existentials which I described in my previous post, but that's a story for my next post.
